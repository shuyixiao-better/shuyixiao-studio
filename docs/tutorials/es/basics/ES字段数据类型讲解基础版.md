# ES字段数据类型讲解基础版

> 映射的数据类型也就是 ES 索引支持的数据类型，其概念和 MySQL 中的字段类型相似，但是具体的类型和 MySQL 中有所区别，最主要的区别就在于 ES 中支持可分词的数据类型，如：Text 类型，可分词类型是用以支持全文检索的，这也是 ES 生态最核心的功能。

想象一下，你有两个图书馆：

1.  **图书馆 A (代表 MySQL 数据库)：**
    *   这个图书馆非常**规矩**。每本书的信息（书名、作者、出版日期、ISBN号）都写在**固定格式的卡片**上，一张卡片对应一个信息项。
    *   管理员（MySQL）非常擅长按**精确的卡片信息**找书。比如：
        *   “请给我**书名 *完全等于* ‘百年孤独’**的书。” → 管理员立刻找到。
        *   “请给我**作者 *完全等于* ‘J.K.罗琳’**的书。” → 管理员立刻找到。
        *   “请给我**出版日期 *是* 2023年1月1日**的书。” → 管理员立刻找到。
    *   **但是！** 如果你想找书*内容*里提到“魔法”的书，管理员就傻眼了。因为卡片上只记录了书名、作者这些固定信息，没有记录书里具体写了什么词！他得一本本翻书去查，效率极低。

2.  **图书馆 B (代表 Elasticsearch 索引)：**
    *   这个图书馆非常**智能**。它不仅记录书名、作者这些基本信息（也写在卡片上），它还有一个**超级厉害的功能**！
    *   它请了一群**图书管理员助理 (分词器)**。他们的工作就是把**每一本书的完整内容**拆开、分析：
        *   助理拿到一本书，比如《哈利波特与魔法石》。
        *   他们**逐页阅读 (分词)**，把书里的句子拆分成一个个独立的单词：“哈利”、“波特”、“与”、“魔法”、“石”、“男孩”、“巫师”、“学校”…… （去掉“的”、“了”等无意义的词）。
        *   然后，他们为**每一个拆分出来的单词**制作一张**索引卡片 (倒排索引)**。卡片上写着这个单词，以及所有包含这个单词的书名和页码。
            *   卡片：“魔法” → 出现在《哈利波特与魔法石》第5页、第87页、第120页…；也出现在《指环王》第45页…；也出现在…
            *   卡片：“哈利” → 出现在《哈利波特与魔法石》第1页、第3页、第10页…；也出现在《哈利波特与密室》第1页…
    *   现在，如果你想找书*内容*里提到“魔法”的书：
        *   你问管理员（Elasticsearch）：“请给我所有内容里包含‘魔法’的书。”
        *   管理员直接去翻“魔法”那张**索引卡片**，瞬间就列出了所有包含“魔法”的书名和具体位置！速度飞快！
    *   更厉害的是，你还可以问：
        *   “请给我内容里包含‘魔法’ *和* ‘学校’的书。” → 管理员查“魔法”卡片和“学校”卡片，找同时出现这两词的书。
        *   “请给我内容里包含‘哈利’ *或* ‘波特’的书。” → 管理员查“哈利”卡片和“波特”卡片，合并结果。
        *   “请给我内容里包含‘魔法石’的书。” → 管理员可能会把“魔法石”拆成“魔法”和“石”两张卡片去找（取决于助理怎么拆），也能找到。

**现在，对应到数据类型：**

*   **MySQL 的字段类型 (如 VARCHAR, INT, DATE)：**
    *   就像**图书馆 A 的固定信息卡片**。它们存储的是**完整的、不可分割**的值。
    *   `书名 = "百年孤独"` -> 整个字符串作为一个整体存储和查询。只能精确匹配。
    *   `价格 = 99.99` -> 精确的数字。
    *   `出版日期 = "2023-01-01"` -> 精确的日期。
    *   **它们不支持**像图书馆 B 那样把内容拆开搜索。

*   **Elasticsearch 的映射数据类型：**
    *   **Text 类型 (可分词类型)：**
        *   这就是图书馆 B 的**超级功能**！它对应的是书的**内容**。
        *   当你把一个字段（比如 `book_content`）定义为 `text` 类型时，Elasticsearch 就会像那些**助理**一样，自动把你存入的内容**拆分成一个个单词 (分词)**，并为这些单词建立**索引卡片 (倒排索引)**。
        *   这就是 ES 实现**超快全文搜索**的核心秘密！让你能根据内容里的单词快速找到相关文档。
    *   **Keyword 类型 (不可分词类型)：**
        *   这更像是**图书馆 A 的卡片**或者**图书馆 B 里记录书名、作者的那些卡片**。
        *   当你把一个字段（比如 `book_title`, `author`, `status`）定义为 `keyword` 类型时，Elasticsearch 会把整个值当作**一个不可分割的整体**存储。
        *   它适合用于：
            *   精确匹配：`author.keyword = "J.K.罗琳"`
            *   排序
            *   聚合统计（比如按状态`status.keyword`分组计数）
        *   它**不会**被分词。如果你想在书名里搜“魔法”，如果书名是 `keyword` 类型，你必须搜索整个书名 `book_title.keyword = "哈利波特与魔法石"` 才能匹配，搜索 `book_title.keyword = "魔法"` 是找不到的（除非真有本书名字就叫“魔法”）。

**总结一下关键区别：**

| 特性         | MySQL 字段类型 (如 VARCHAR)          | Elasticsearch 数据类型                          |
| :----------- | :----------------------------------- | :---------------------------------------------- |
| **核心用途** | 存储精确值，支持精确匹配、排序、计算 | 存储数据，支持**全文搜索**、精确匹配、排序、聚合 |
| **分词能力** | ❌ **没有分词概念**                   | ✅ **有专门的分词类型 (`text`)**                |
| **类比**     | 图书馆A的固定信息卡片                | `text`类型：书的内容索引卡； `keyword`类型：书名/作者卡 |
| **搜索特点** | 只能精确匹配整个字段值               | `text`类型：可按内容中的单词搜索； `keyword`类型：需精确匹配整个字段值 |

**简单来说：**

*   如果你想搜文章内容、商品描述、日志信息里**包含哪些词**，就用 **`text`** 类型。这是 ES 的看家本领。
*   如果你想按品牌、状态、ID、标签（这些通常是固定的、有限的选项）进行**精确筛选、排序或统计**，就用 **`keyword`** 类型。
